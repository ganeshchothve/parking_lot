c
action_name
controller_name
c
user.role
confirmed_and_ready_user?
valid
n
index?
c
BookingDetail.delete_all
BookingDetail.count
pp record.user.booking_details.last.class
pp record.user.booking_details.pluck(:created_at)
record.user.booking_details.pluck(:created_at)
record.user.booking_details.count
record.user.booking_details.nin(status: %w[cancelled swapped]).count
record.user.allowed_bookings
record.user.allowed_bookings > record.user.booking_details.nin(status: %w[cancelled swapped]).count
record.user_based_status(record.user) == 'available'
record.user.project_units.where(status: 'hold').blank?
valid
c
n
c
Buyer::ProjectUnitPolicy.new(current_user, ProjectUnit.new(user: current_user, status: "available")).hold?
c
self.booking_detail
self.booking_detail.booking_detail_scheme
self.booking_detail.present?
["blocked", "booked_tentative", "booked_confirmed"].include?(self.status)
self.scheme
scheme_id
exit
@project_unit.booking_detail_scheme
@project_unit.booking_detail
@project_unit.booking_detail_scheme
@project_unit
@alternate_project_unit.booking_detail_scheme
ProjectUnit.last.booking_detail_scheme
ProjectUnit.last.scheme
ProjectUnit.last.scheme_id
ProjectUnit.last
@alternate_project_unit.scheme_id
@alternate_project_unit
@alternate_project_unit.class
c
"#{user.buyer? ? 'Buyer' : 'Admin'}::Audit::RecordPolicy".constantize.new(user, Audit::Record.new).index?
user
record
c
cc
c
a = "#{current_user.buyer? ? 'Buyer' : 'Admin'}::Audit::RecordPolicy"c
a = "#{current_user.buyer? ? 'Buyer' : 'Admin'}::Audit::RecordPolicy"
a
a = "#(current_user.buyer? ? 'Buyer' : 'Admin')::Audit::RecordPolicy"
"#(current_user.buyer? ? 'Buyer' : 'Admin')::Audit::RecordPolicy"
eval("#(current_user.buyer? ? 'Buyer' : 'Admin')::Audit::RecordPolicy")
eval("#(current_user.buyer? ? 'Buyer' : 'Admin')::Audit::RecordPolicy.index?")
policy(:custom)eval("#(user.buyer? ? 'Buyer' : 'Admin')::Audit::R
policy(:custom).audits?
method
c
method
c
method
c
method
exit
policy(:custom).audits?
method
c
method
c
method
c
method
policy(:custom).audits?
c
Client.
Clien.count
c
policy([ current_user_role_group, project_unit.user.receipts.new(project_unit_id: project_unit.id)]).new?
n
ProjectUnitPolicy.new(current_user, project_unit).block?
c
valid
n
valid
n
record.user.user_requests.where(project_unit_id: record.project_unit_id).where(status: "pending").blank?
c
record.user.user_requests.where(project_unit_id: record.project_unit_id).where(status: "pending").blank?
c
record.user.user_requests.where(project_unit_id: record.project_unit_id).count
record.user.user_requests.where(project_unit_id: record.project_unit_id).where(status: "pending").count
record.user.user_requests.where(project_unit_id: record.project_unit_id).where(status: "pending").blank?
rcord.user.user_requests.where(project_unit_id: record.project_unit_id).where(status: "pending").blank?
cord.user.user_requests.where(project_unit_id: record.project_unit_id).where(status: "pending").blank?
record.project_unit_id.present?
valid
n
record.user.user_requests.where(project_unit_id: record.project_unit_id).where(status: "pending").blank?
c
record.user.user_requests.where(project_unit_id: record.project_unit_id).where(status: "pending").blank?
record.user.user_requests.where(project_unit_id: record.project_unit_id).pluck(:status)
record.user.user_requests.where(project_unit_id: record.project_unit_id).count
record.user.user_requests.where(project_unit_id: record.project_unit_id)
ecord.user.user_requests.where(project_unit_id: record.project_unit_id)
valid
record.project_unit_id.present?
n
(record.project_unit_id.blank? || after_hold_payment? || after_blocked_payment? || after_under_negotiation_payment?)
record.project_unit_id.blank? || after_hold_payment? || after_blocked_payment? || after_under_negotiation_payment?)
confirmed_and_ready_user?
user.buyer?
user.email
user.role
exit
c
policy([ current_user_role_group, receipt]).edit?
policy([ current_user_role_group, receipt])
receipt.class
current_user_role_group
c
(ProjectUnit.available_statuses.find{|x| x[:id] == d[:status]} || {}).dig(:text)
ProjectUnit.available_statuses.find{|x| x[:id] == d[:status]}.dig(:text)
d[:status]
ProjectUnit.available_statuses.find{|x| x[:id] == d[:status]}[:text]
c
ProjectUnit.available_statuses.find{|x| x[:id] == d[:status]}[:text]
c
ProjectUnit.available_statuses.find{|x| x[:id] == d[:status]}[:text]
c
ProjectUnit.available_statuses.find{|x| x[:id] == d[:status]}[:text]
ProjectUnit.available_statuses.find{|x| x[:id] == d[:status]}
d[:status]
ProjectUnit.available_statuses
c
project_unit.set(status: 'available', user_id: nil)
project_unit.booking_detail.delete
project_unit.booking_detail
project_unit.receipts.delete_all
project_unit.receipts.count
project_unit.receipts
project_unit
project_unit.booking_detail.scheme
project_unit.booking_detail.schem
project_unit.booking_detail.scheme
project_unit.booking_detail
project_unit.booking_details
project_unit.status
project_unit.scheme
project_unit.cost_sheet_template
project_unit
c
self.scheme.payment_schedule_template
scheme_id.present?
self.scheme
self
c
booking_detail.status
c
booking_detail.status
c
self.project_unit.total_tentative_amount_paid
self.project_unit.total_amount_paid
self.project_unit.receipts.pluck(:status)
self.project_unit.receipts.status
self.project_unit.receipts.count
self.project_unit.receipts
self.project_unit.total_tentative_amount_paid >= self.project_unit.blocking_amount
self.project_unit.total_amount_paid > self.project_unit.blocking_amount
self.project_unit.pending_balance({strict: true}) <= 0
self.booking_detail_scheme_status == "approved"
self.booking_detail_status
booking_detail.status
booking_detail
c
project_unit.reload.status
project_unit.status
project_unit
project_unit.status
c
params
@receipt.errors.as_json
@receipt.valid?
@receipt.payment_mode
@receipt
exit
params
parameters
c
user.buyer?
current_client.enable_actual_inventory?(user)
c
@project_unit.update(parameters)
c
n
action_name
params[:action] == "new" || params[:action] == "create"
n
params[:action] == "index"
c
@user.blank?
c
user.role
user.role?('superadmin')
current_client.enable_actual_inventory?(user)
index?
current_client.enable_actual_inventory?(user)
user.email
user
current_client.name
current_client.email
current_client
c
authorize BookingDetailScheme.new(created_by: current_user, project_unit_id: project_unit_id)
n
c
n
c
project_unit.permitted_schemes(current_user).count
project_unit.permitted_schemes(current_user)
current_user.email
current_user,email
current_user
exit
project_unit.permitted_schemes(current_user).pluck(:_type)
project_unit.permitted_schemes(current_user).collect{|scheme| [scheme.name, scheme.id]}
current_user
project_unit.id
project_unit.class
c
current_user.user_kycs.count
params[:small] 
c
ProjectUnit.available_statuses(current_client)
project_unit.status
pp ProjectUnit.available_statuses
current_client.try(:enable_company_users?)
ProjectUnit.available_statuses.find{|x| x[:id] == project_unit.status}
project_unit.status
project_unit
ProjectUnit.available_statuses
c
user.project_ids
record.project_id.present?
c
record.user_id.present?
!user.buyer?
is_valid_record?
c
record.project_unit_id.blank? || after_blocked_payment? || (after_hold_payment? && editable_field?('event'))
c
